/* parser.y */

%{
    #include <stdio.h>
    #include <math.h>
    #include "global.h"

    extern int yyerror(char const *msg);
    extern int yylex();


    #define MAX_ARGS 4

    struct TreeNode {
        int type;
        int leaf_value;
        TreeNode* args[MAX_ARGS];
    };

    TreeNode* mkleaf(int type, int value);
    TreeNode* mknode(int type, TreeNode* a0=0, TreeNode* a1=0, TreeNode* a2=0, TreeNode* a3=0);
    void print_syntax_tree(TreeNode* n);
    void printtree1(TreeNode* p, int level);
%}

%union {
    struct TreeNode* p;
    int iValue;
}
%type <p> stmt expr list; // assignment;

%token <iValue> ID <iValue> NUM DONE WHILE ELSE IF PRINT READ
%left '&' '|' '<' '>' '?' ':'
%left '+' '-'
%left '*'
%left '/' '%'
%left '^'

%%

start:
    list DONE                   { print_syntax_tree($1); }
    ;
list:
      stmt ';' list             { $$ = mknode(';', $1, $3); }
    | /* empty */               { $$ = mknode(' '); }
stmt:
      expr                                                      { $$ = $1; }
    | ID '=' expr                                               { $$ = mknode('=', mkleaf(ID, $1), $3); }
    | WHILE '(' expr ')' '{' list '}'                      { $$ = mknode(WHILE, $3, $6); }
    | IF '(' expr ')' '{' list '}' ELSE '{' list '}'  { $$ = mknode(IF, $3, $6, $10); }
    | PRINT '(' ID ')'      { $$ = mknode(PRINT, mkleaf(ID, $3)); }
    | READ '(' ID ')'       { $$ = mknode(READ, mkleaf(ID, $3)); }
    ;
expr :
      NUM                     { $$ = mkleaf(NUM, $1); } //printf("%d\n", $1); }
    | ID                      { $$ = mkleaf(ID, $1); } //$$ = symtable[$1].value; printf("%d\n", symtable[$1].value); }
    | expr '+' expr           { $$ = mknode('+', $1, $3); } //$$ = $1 + $3; printf("+\n"); }
    | expr '-' expr           { $$ = mknode('-', $1, $3); } //$$ = $1 - $3; printf("-\n"); }
    | expr '*' expr           { $$ = mknode('*', $1, $3); } //$$ = $1 * $3; printf("*\n"); }
    | expr '/' expr           { $$ = mknode('/', $1, $3); } //$$ = $1 / $3; printf("/\n"); }
    | expr '%' expr           { $$ = mknode('%', $1, $3); } //$$ = $1 % $3; printf("%%\n"); }
    | expr '^' expr           { $$ = mknode('^', $1, $3); } //$$ = pow($1, $3); printf("^\n"); }
    | expr '&' expr           { $$ = mknode('&', $1, $3); } //$$ = $1 & $3; printf("&\n"); }
    | expr '|' expr           { $$ = mknode('|', $1, $3); } //$$ = $1 | $3; printf("|\n"); }
    | expr '<' expr           { $$ = mknode('<', $1, $3); } //$$ = $1 < $3; printf("<\n"); }
    | expr '>' expr           { $$ = mknode('>', $1, $3); } //$$ = $1 > $3; printf(">\n"); }
    | '(' expr ')'            { $$ = $2; }  //$$ = mknode('(', $1, $3); } //
    | expr '?' expr ':' expr  { $$ = mknode('?', $1, $3, $5); } //$$ = $1 ? $3 : $5; printf("?\n"); }
    ;

%%

TreeNode* mkleaf(int type, int value) {
  TreeNode* p = new TreeNode();
  p->type = type;
  p->leaf_value = value;
  return p;
}

TreeNode* mknode(int type, TreeNode* a0, TreeNode* a1, TreeNode* a2, TreeNode* a3) {
  TreeNode* p = new TreeNode();
  p->type = type;
  p->args[0] = a0;
  p->args[1] = a1;
  p->args[2] = a2;
  p->args[3] = a3;
  return p;
}


void print_syntax_tree(TreeNode* p) {
  printf("Syntax tree:\n");
  printtree1(p, 0);
}

void printtree1(TreeNode* p, int level) {
    if (p==0)
        return;
    printf("%*s", level, "");
    /* printf("%d %c ", level, p->type); */
    switch (p->type) {
        case '=':
            printf("=\n");
            printtree1(p->args[0], level + 4);
            printtree1(p->args[1], level + 4);
            break;
        case IF:
            printf("if\n");
            printtree1(p->args[0], level + 4);
            printtree1(p->args[1], level + 4);
            printtree1(p->args[2], level + 4);
            break;
        case WHILE:
            printf("while\n");
            printtree1(p->args[0], level + 4);
            printtree1(p->args[1], level + 4);
            break;
        case PRINT:
            printf("print\n");
            printf("%*s", level+ 4, "");
            printf("%s\n", symtable[p->leaf_value].lexeme);
            break;
        case READ:
            printf("read\n");
            printf("%*s", level+ 4, "");
            printf("%s\n", symtable[p->leaf_value].lexeme);
            break;
        case ID:
            printf("%s\n", symtable[p->leaf_value].lexeme);
            break;
        case NUM:
            printf("%d\n", p->leaf_value);
            break;
        case '+':  case '-': case '*': case '/': case '%': case '^': case '&': case '|': case '<': case '>':
            printf("%c\n", p->type);
            printtree1(p->args[0], level + 4);
            printtree1(p->args[1], level + 4);
            break;
        case '?':
            printf("%c\n", p->type);
            printtree1(p->args[0], level + 4);
            printtree1(p->args[1], level + 4);
            printtree1(p->args[2], level + 4);
            break;
        case ';':
            printtree1(p->args[0], level);
            /* printf("%*s", level, ""); */
            printf(";\n");
            /* printtree1(p->args[1], level); */
            break;
    }
}

int yyerror(char const *msg) {
    printf("Error: %s\n", msg);
    return 0;
}

int main() {
    yyparse();
    exit(0);
}
